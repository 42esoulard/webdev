---------------------------
    ORGANIZING JS CODE 
---------------------------


    Plain Old JavaScript Objects and Object Constructors
    Factory Functions and the Module Pattern
    Classes
    ES6 Modules

-----------------------
        OBJECTS 
-----------------------

INSTANTIATE, ACCESS, DOS AND DONT :
    const myObject = {
    property: 'Value!',
    otherProperty: 77,
    "obnoxious property": function() {
        // do stuff!
      }
    }

    // dot notation
    myObject.property // 'Value!'

    // bracket notation
    myObject["obnoxious property"] // [Function]

    const variable = 'property'
    myObject.variable // this gives us 'undefined' because it's looking for a property named 'variable' in our object
    myObject[variable] // this is equivalent to myObject['property'] and returns 'Value!'

As much as possible, group related variables in an object for cleaner code.

For an object which will be instanciated multiple times, create a constructor function:
    function Player(name, marker) {
        this.name = name
        this.marker = marker
        this.sayName = function() {
            console.log(name)
        }
    }

    const player = new Player('steve', 'X')
    console.log(player.name) // 'steve'
    player.sayName() //'steve

It is almost always best to return things rather than putting console.log() directly into the function

------> Object prototype:
All object inherit from their prototype
 __proto__ use is not generally recommended. It is an attribute of every
 instance of a prototype, and it points to the parent prototype.

Prefer Object.create(parent.prototype)

We can edit an object prototype by accessing its prototype:
    function PrintStuff (myDocuments) {
        this.documents = myDocuments;
    }
    // We add the print () method to PrintStuff prototype property so that other instances (objects) can inherit it:
    PrintStuff.prototype.print = function () {
        console.log(this.documents);
    }
    //Now if we instanciate a PrintStuff, it will have the print() function

Objects also have a constructor property pointing to their constructor:
    var myObj = new Object ();
    console.log(myObj.constructor); // Object()
By default if not specified, the object inherits from Object and has Object()
as its prototype attribute
    var userAccount = {name: “Mike”} //userAccount.prototype is Object()
But
    function Account () {}
    var userAccount = new Account () //userAccount.prototype is Account()

PROTOTYPES INHERITING FROM OTHERS:
    function Plant () {
        this.country = "Mexico";
        this.isOrganic = true;
    }

    // Add the showNameAndColor method to the Plant prototype property
    Plant.prototype.showNameAndColor =  function () {
        console.log("I am a " + this.name + " and my color is " + this.color);
     }

    // Add the amIOrganic method to the Plant prototype property
    Plant.prototype.amIOrganic = function () {
        if (this.isOrganic)
            console.log("I am organic, Baby!");
    }

    function Fruit (fruitName, fruitColor) {
        this.name = fruitName;
        this.color = fruitColor;
    }

    // Set the Fruit's prototype to Plant's constructor, thus inheriting all of Plant.prototype methods and properties.
    Fruit.prototype = new Plant ();

    // Creates a new object, aBanana, with the Fruit constructor
    var aBanana = new Fruit ("Banana", "Yellow");

    // Here, aBanana uses the name property from the aBanana object prototype, which is Fruit.prototype:
    console.log(aBanana.name); // Banana

    // Uses the showNameAndColor method from the Fruit object prototype, which is Plant.prototype. The aBanana object inherits all the properties and methods from both the Plant and Fruit functions.
    console.log(aBanana.showNameAndColor()); // I am a Banana and my color is yellow.

THE PROTOTYPE CHAIN:
If an attribute isn't found in a child, it's looked up 
in its prototype. If it still isn't, it's looked up in the 
prototype's prototype. And if it isn't... this goes on
all the way up the family tree and if it isn't found,
undefined is returned. 
Parent properties can be overwritten in children.

OBJECT PROPERTIES INHERITED BY ALL OBJECTS:
All objects in JavaScript inherit properties and methods from Object.prototype:
    constructor, 
    hasOwnProperty (), 
    isPrototypeOf (), 
    propertyIsEnumerable (), 
    toLocaleString (), 
    toString (), 
    valueOf ()

WHAT ABOUT THIS:
No matter where the method is found: in an object or its prototype. 
In a method call, this is always the object before the dot.

ITERATING ON OBJECT ATTRIBUTES:
Object.keys(myobject): iterates only on object's own keys
for...in: iterates on inherited properties too!
But Object() inherited properties are not listed.
    let animal = {
        eats: true
    };

    let rabbit = {
        jumps: true,
        __proto__: animal
    };

    // Object.keys only returns own keys
    alert(Object.keys(rabbit)); // jumps

    // for..in loops over both own and inherited keys
    for(let prop in rabbit) alert(prop); // jumps, then eats

Check if obj has own property (not inherited):
obj.hasOwnProperty(key): it returns true if obj has its own (not inherited) property named key

/!\ Prefer to define functions of an object on its prototype
rather than in its constructor, for optimization reasons to save memory.
 
/!\ Use Object.create to set an object's prototype:
    function Student() {
    }

    Student.prototype.sayName = function() {
        console.log(this.name)
    }

    function EighthGrader(name) {
        this.name = name
        this.grade = 8
    }

    EighthGrader.prototype = Object.create(Student.prototype)

    const carl = new EighthGrader("carl")
    carl.sayName() // console.logs "carl"
    carl.grade // 8
DO NOT DO EighthGrader.prototype = Student.prototype


-----------------------------------------------------------------------------------

-----------------------
      CONSTRUCTOR 
-----------------------

Instead of having to use new Constructor(),
use a Factory Function, a function which returns
a new object:
    const personFactory = (name, age) => {
        return { name, age, sayHello };
    };

This line directly returns an object where this.name=name, etc:
    return {name, age, sayHello}
To print variable names + values:
    console.log({name, color, number, food})

-----------------------
         SCOPE 
-----------------------
scope === which variable i can access
context === what 'this' refers to

Factory functions: we can only access what they return.
So the variables and functions inside are accessible to whatever the return
tries to access, but from the outside we can't.
They allow us to create private variables:
    const counterCreator = () => {
    let count = 0;//count is private
    return () => {
        console.log(count);//any instance of counterCreator can access count
        count++;
     };
    };

    const counter = counterCreator();
    counter(); // 0
    counter(); // 1
    counter.count //ERROR, not accessible from the outside

Private functions are functions that are used in the workings of our 
objects that are not intended to be used elsewhere in our program.
    const FactoryFunction = string => {
        const capitalizeString = () => string.toUpperCase();
        const printString = () => console.log(`----${capitalizeString()}----`);
        return { printString };
    };
DO THINGS THIS WAY AS OFTEN AS POSSIBLE, CLEANER CODE, SMALLER FUNCTIONS
WHILE KEEPING THEM OUT OF THE WAY AND OUT OF SCOPE! NICE!

Everything publicly exposed can be changed from the outside

------> Inheritance w factory functions:

    const Person = (name) => {
        const sayName = () => console.log(`my name is ${name}`)
        return {sayName}
    }

    const Nerd = (name) => {
    // simply create a person and pull out the sayName function with destructuring assignment syntax!
        const {sayName} = Person(name)
        const doSomethingNerdy = () => console.log('nerd stuff')
        return {sayName, doSomethingNerdy}
    }

    const jeff = Nerd('jeff')

    jeff.sayName() //my name is jeff
    jeff.doSomethingNerdy() // nerd stuff

Or even assign all of the parent to the returned object:
    const Nerd = (name) => {
        const prototype = Person(name)
        const doSomethingNerdy = () => console.log('nerd stuff')
        return Object.assign({}, prototype, {doSomethingNerdy})
    }

------> CLASSICAL INHERITANCE VS PROTOTYPAL INHERITANCE
    Classical: In C++ and Java, inheritance is from a blueprint, not an instance
    Prototypal: In JS, inheritance is from an existing object, a delegate prototype.
    
    When you inherit from a delegate prototype, the new object gets a reference 
to the prototype. Properties are looked for up the prototype chain.
Method delegation can preserve memory resources because you only need 
one copy of each method to be shared by all instances. 

------> Module pattern:
Basically IIFE but for Factory Function: 
    var myModule = (function() {
    'use strict';

    return {
        publicMethod: function() {
        console.log('Hello World!');
        }
    };
    })();

    myModule.publicMethod(); // outputs 'Hello World'